### *сделано вместе с https://github.com/alextrsv*

# Лабораторная работа №1: Интерфейсы ввода/вывода общего назначения (GPIO)

**Цель работы**
1. Получить базовые знания о принципах устройства стенда SDK-1.1M и программировании микроконтроллеров.
2. Изучить устройство интерфейсов ввода-вывода общего назначения (GPIO) в микроконтроллерах и приемы их использования.

**Задание**
Разработать и реализовать драйверы управления светодиодными индикаторами и чтения состояния кнопки стенда SDK-1.1М (индикаторы и кнопка расположены на боковой панели стенда). Функции и другие компоненты драйверов должны быть универсальными, т.е. пригодными для использования в любом из вариантов задания и не должны содержать прикладной логики программы. Функции драйверов должны быть неблокирующими, то есть не должны содержать задержек на определенное время с использованием активного ожидания (функция HAL_Delay() и варианты ее ручной реализации), а также активного ожидания событий в циклах. Написать программу с использованием разработанных драйверов в соответствии с вариантом задания.

**Вариант 2**
Реализовать простой имитатор гирлянды с переключением режимов. Должно быть
реализовано не менее четырех последовательностей переключения светодиодов, обязательно с разной частотой мигания. В каждом режиме задействуется не менее двух светодиодов. По нажатию кнопки происходит циклическое переключение режимов. При повторном входе в какой-либо режим анимация на светодиодах должна запускаться с того места, на котором в прошлый раз была прервана переключением на следующий режим.

# Лабораторная работа 2. Последовательный интерфейс UART

**Цели работы:**
1. Изучить протокол передачи данных с помощью интерфейса UART.
2. Получить базовые знания об организации системы прерываний в микроконтроллерах на примере микроконтроллера STM32.
3. Изучить устройство и принципы работы контроллера интерфейса UART, получить навыки организации обмена данными по UART в режимах опроса и прерываний.

**Задание**
Разработать и реализовать два варианта драйверов UART для стенда SDK-1.1M: с использованием и без использования прерываний. Драйверы, использующие прерывания, должны обеспечивать работу в «неблокирующем» режиме (возврат из функции происходит сразу же, без ожидания окончания приема/отправки), а также буферизацию данных для исключения случайной потери данных. В драйвере, не использующем прерывания, функция приема данных также должна быть «неблокирующей». Прерывания от соответствующего блока UART должны быть запрещены при использовании режима «без прерываний».
Написать с использованием разработанных драйверов программу, которая выполняет определенную вариантом задачу. Для всех вариантов должно быть реализовано два режима работы программы: с использованием и без использования прерываний. Каждый принимаемый стендом символ должен отсылаться назад – так называемое «эхо». Каждое новое сообщение от стенда должно выводиться с новой строки. Если вариант предусматривает работу с командами, то на каждую команду должен выводиться ответ, определенный в задании или «ОК», если ответ не требуется. Если введена команда, которая не поддерживается, должно быть выведено сообщение об этом.

**Вариант 2**
Доработать программу «гирлянда», реализовав возможность добавления четырёх новых
последовательностей миганий светодиодов с индивидуальной настройкой частоты переключения состояний для каждой последовательности. Каждая вводимая последовательность должна иметь от двух до восьми состояний. В один момент времени может гореть только один светодиод (или не гореть ни один). Смена отображаемой в данный момент последовательности должна осуществляться нажатием кнопки или командой, посылаемой через UART.
Должны обрабатываться следующие команды, посылаемые через UART:
− `new xx...` – ввести новую последовательность, где «x» – это одна из букв `g, r, y, n` («g» соответствует включению зелёного светодиода, «r» - красного, «y» - жёлтого, «n» означает, что ни один светодиод не горит); количество вводимых значений «x» может быть от двух до восьми, ввод завершается либо по нажатию enter, либо после ввода восьми значений; после окончания ввода последовательности мерцаний стенд должен послать сообщение произвольного содержания, приглашающее ввести частоту мерцаний светодиодов (должны предусматриваться минимум три градации); ввод частоты мерцаний заканчивается по нажатию enter; новой последовательности присваивается очередной свободный номер от 5 до 8; если уже есть 8 последовательностей, то переопределяется последовательность 5 и т.д.; номер новой
сохраненной последовательности выводится в UART;
− `set х` – сделать активной последовательность мерцаний х, где х – порядковый номер;
− `set interrupts on` или `set interrupts off` – включить или выключить прерывания.

# Лабораторная работа 3. Таймеры и интерфейс I2C

**Цели работы**
1. Получить навыки использования прерываний от таймеров и аппаратных каналов ввода-вывода таймеров.
2. Изучить интерфейс I2C (inter-integrated circuit, т.е. межмикросхемный интерфейс) и особенности передачи данных по данному интерфейсу.
3. Изучить устройство и принципы работы контроллера интерфейса I2C в STM32 и получить навыки его программирования.

**Задание**
Разработать программу, которая включает драйвер клавиатуры. Драйвер может быть организована одним из трех основных способов:
1. Работа с I2C по опросу (без прерываний от I2C). Опрос клавиатуры периодически выполняется из главного цикла while() в функции main(). При этом остальной код главного цикла должен отдавать управления достаточно быстро, чтобы не создавать заметных пауз в опросе клавиатуры.
2. Работа с I2C по прерываниям в главном цикле. Аналогично предыдущему, функции опроса клавиатуры вызываются из главного цикла, но используются функции, работающие в режиме прерывания, Для получения результата надо дожидаться окончания выполнения транзакций (их можно отслеживаться с помощью callback-функций).
3. Работа с I2C по прерываниям в отдельном потоке. Помимо главного цикла программа должна иметь еще один поток управления, который отвечает за опрос клавиатуры. Для этого необходимо настроить один из таймеров микроконтроллера так, чтобы он регулярно генерировал прерывания в режиме автоперезагрузки. В обработчике прерывания от данного таймера необходимо генерировать посылки для обмена по шине I2C в режиме прерываний. Таким образом, полный опрос клавиатуры требует 8 прерываний от таймера. Период между прерываниями должен обеспечивать достаточный запас времени на выполнение транзакций I2C и работу основного цикла. При этом регистрация нажатия должна происходить достаточно быстро, чтобы пользователь не чувствовал задержки отклика. Оценить время, необходимое на выполнение транзакции достаточно просто, так как известно время передачи одного бита и количество данных. При частоте шины 400 кГц один бит передается за 2,5 мкс, а транзакция в 4 байта занимает не более 0,1 мс. Начальная инициализация устройств I2C (если требуется) может быть сделана до того, как будет запущен процесс опроса клавиатуры.
Подсистема опроса клавиатуры должна удовлетворять следующим требованиям:
− реализуется защита от дребезга;
− нажатие кнопки фиксируется сразу после того, как было обнаружено, что кнопка
нажата (с учетом защиты от дребезга), а не в момент отпускания кнопки; долгое нажатие может фиксироваться отдельно;
− кнопка, которая удерживается дольше, чем один цикл опроса, не считается повторно нажатой до тех пор, пока не будет отпущена;
− распознается и корректно обрабатывается множественное нажатие (при нажатии более чем одной или двух кнопок считается, что ни одна кнопка не нажата);
− всем кнопкам назначаются коды от 1 до 12 (порядок на усмотрение исполнителей);
− зафиксированные события нажатия кнопок помещаются в программный FIFO-буфер, из которого их может считывать процесс (поток управления), реализуемый главным циклом функции main();
− доступ к буферу должен быть защищен от состояния гонки в моменты модификации указателей критическими секциями с запретами прерываний (см. описание лабораторной работы No2).

В главном цикле функции main() выполняется основной поток управления который может работать в двух режимах, переключение между которыми производится по нажатию кнопки на боковой панели стенда:
− режим тестирования клавиатуры;
− прикладной режим.
Уведомление о смене режима выводится в UART. В режиме тестирования клавиатуры программа выводит в UART коды нажатых кнопок. В прикладном режиме программа обрабатывает нажатия кнопок и выполняет действия в
соответствии с вариантом задания. Управление звукоизлучателем и яркостью светодиодов должно выполняться с помощью таймеров (по прерыванию или с использованием аппаратных каналов). Блокирующее ожидание (функция HAL_Delay()) использоваться не должно.

**Вариант 2**
Реализовать настраиваемый пульт включения разных режимов горения светодиодов. По нажатию кнопок клавиатуры выполняются следующие действия:
*Код кнопки/Действие*
1-9: 
    Зажигание светодиода в соответствии с режимом. Предыдущий режим горения отключается, новый режим держится до переключения на следующий режим. Режимы по умолчанию:
    1 – зеленый, 10 % яркости
    2 – зеленый, 40 % яркости 
    3 – зеленый, 100 % яркости 
    4 – желтый, 10 % яркости
    5 – желтый, 40 % яркости
    6 – желтый, 100 % яркости 
    7 – красный, 10 % яркости 
    8 – красный, 40 % яркости 
    9 – красный, 100 % яркости
10:
    Отключить текущий режим (погасить все светодиоды).
11: 
    Войти в меню настройки.
12:
    Выйти из меню настройки.

По нажатию каждой кнопки в UART должно выводиться сообщение о том, какой режим активирован, или текущие настройки, вводимые в меню.
После входе в меню настройки сначала надо нажать кнопку, привязанный к которой режим требуется изменить, далее кнопками 1 – 3 выбирается светодиод (зеленый, желтый, красный) и кнопками 4, 5 – коэффициент заполнения от 0 до 100 % с шагом 10 %. По нажатию кнопки выхода из меню новый режим сохраняется.